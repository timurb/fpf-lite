# Рекомендация для кодинга

Проанализировав наш диалог и архитектурные решения для «Фабрики Знаний» (Knowledge Factory), я вижу, что мы использовали очень конкретное подмножество FPF.

Мы строили **детерминированную инженерную систему** (Data Engineering / System Architecture), а не занимались научным поиском, эволюционными алгоритмами или сложной онтологической унификацией.

Вот список того, что можно **безопасно удалить**, так как эти концепции не использовались для генерации результата и не понадобятся для реализации кода в IDE.

### 1. Кандидаты на удаление (Unused / Dead Weight)

#### Группа: Эволюционные вычисления и Поиск (Самый большой балласт)
Мы строим «Фабрику» (Batch Pipeline), а не «Эволюционный поиск решений». Вся математика NQD (Novelty-Quality-Diversity) здесь лишняя.
*   **Удалить A.0:** Onboarding Glossary (NQD & E/E-LOG).
*   **Удалить C.17, C.18, C.19:** Creativity-CHR, NQD-CAL, E/E-LOG.
*   **Удалить B.5.2.1:** Creative Abduction with NQD.

#### Группа: SoTA и Академический Харвестинг
Мы не пишем научную статью и не сравниваем алгоритмы бенчмарками. Нам нужно просто запустить код.
*   **Удалить Весь Part G (G.0 — G.13):** SoTA Harvester, Parity Harness, Telemetry. (Единственное исключение — G.10 упоминался в контексте MVPK, но концепции MVPK достаточно в E.17).

#### Группа: Тяжелая Онтология и Унификация
Мы работаем в рамках одного проекта, нам не нужно сводить терминологию разных научных школ (BPMN vs PROV-O и т.д.) через сложные таблицы.
*   **Удалить Весь Part F (F.0.1 — F.18):** Unification Suite.
    *   *Нюанс:* Мы использовали понятия «Context» и «Role Description», но они определены и в Part A (Kernel). Сложные таблицы SenseCells и Concept-Sets нам не нужны.

#### Группа: Этика и Конфликты
*   **Удалить Весь Part D (D.1 — D.5):** Ethics & Conflict-Optimisation. Для технической реализации ETL-пайплайна это сейчас оверхед.

#### Группа: Сложная Математика и Калькулусы (CALs)
Мы использовали концепты, но не формулы.
*   **Удалить C.1 (Sys-CAL), C.4 (Method-CAL), C.5 (Resrc-CAL), C.6 (LOG-CAL), C.13 (Compose-CAL).**
*   **Удалить B.1 и подпункты:** Universal Algebra of Aggregation (нам достаточно интуитивного понимания "часть-целое", формулы инвариантов не нужны).
*   **Удалить B.2 и подпункты:** Meta-Holon Transition (мы не моделируем эмерджентность роя дронов).

---

### 2. Что ОБЯЗАТЕЛЬНО оставить (The Core)

Эти паттерны использовались в каждом промпте и ответе. Если их удалить, следующая LLM перестанет понимать структуру папок и логику разделения "Файл vs Смысл".

#### Part A: Kernel (Фундамент)
*   **A.1 (Holon) & A.1.1 (BoundedContext):** Основа изоляции данных.
*   **A.2 (Role) & A.2.1 (RoleAssignment):** Чтобы различать `Worker` (скрипт) и `Architect` (человек).
*   **A.3 (Transformer Quartet):** Разделение на `MethodDescription` (YAML-конфиг) и `Work` (лог выполнения). **Критично.**
*   **A.4 (Temporal Duality):** Design-time vs Run-time.
*   **A.7 (Strict Distinction):** Главный принцип. Разделение `Carrier` (файл) и `Episteme` (знание).
*   **A.10 (Evidence Graph):** Требование ссылок (`[Source: ...]`).
*   **A.15 (Role-Method-Work Alignment):** Связка "Кто - Как - Что сделал".

#### Part B: Reasoning (Логика)
*   **B.3 (Trust & Assurance):** Концепция `F-G-R`. Нам нужно только определение уровней доверия, формулы можно сократить.
*   **B.5.1 (Explore-Shape-Evidence-Operate):** Для понимания статусов артефактов.

#### Part E: Authoring (Формат вывода)
*   **E.8 (Template):** Чтобы LLM знала, как оформлять Markdown.
*   **E.9 (DRR):** Формат архитектурных решений.
*   **E.10 (LEX):** Словарь и правила именования.
*   **E.17 (MVPK):** Формат `TechCard`, `PlainView` (мы это активно использовали).

---

### 3. Резюме: Как сократить FPF.md

Для задачи "Кодинг в Cursor" вы можете сократить FPF **на 70-80%**.

**Оставьте только:**
1.  **Part A** (Целиком, это словарь типов).
2.  **Part B** (Только B.3, B.5.1).
3.  **Part E** (E.8, E.9, E.10, E.17).

Всё остальное (Part C, D, F, G) — это инструменты для *системного анализа и онтологического инжиниринга*, которые на этапе *написания кода на Python* будут только занимать контекстное окно.